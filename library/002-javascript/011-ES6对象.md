## ES6 对象
1.对象写法更加简化(只能在json对象中写)
* 当属性名与属性值变量名一致时，可以省略属性值
* 方法可以省略function关键字

```js
var obj={
    user:user,
    fun:function(){}
}

```
```js
var obj={
    user,
    fun(){}
}
```

## ES6 类
```js
class name{
    <!--构造函数-->
    constructor (user,age){
        this.user=user;
        this.age=age;
    }
    
    <!--原型-->
    run(){
        alert(1)
    }
}
new name
```
```js
// 类
class abc{
    // 构造函数
    constructor(user,age){
        this.user=user;
        this.age=age;
    }
    // 原型
    run(){
        alert(1);
    }
}
var a=new abc("tony",20)
a.run();
```
### 类的继承
extends 继承父类的原型

super() 继承父类的构造函数
```js
class fu{
    constructor(){
        this.massage="fu"
    }
    run(){
        alert("父构造函数的原型")
    }
}
class zi extends fu{
    constructor(){
        super() //把父类构造函数中的内容拿过来，()里可以给父构造函数传参
        this.massage="zi"
    }
    run(){
        alert("子构造函数的原型")
    }
}
```
## object 对象的方法

### 创建对象 object.create()
```js
Object.create(原型,{属性方法})

Object.create({},{
    user:{
        value:'tony',  //默认值
        configurable:false,  //不可删除
        writable:false,  //不可编辑
        enumerable:false  //不可遍历
    }
    fun(){
        alert(1)
    }
})
```
#### 属性描述符
* value：该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。
* configurable：当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false (不可删除)。
* writable：当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false (不可修改)。
* enumerable：当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false (不会被遍历)。

### 判断两个数据是否相同
```js
Object.is(NaN,NaN)
```
### 拼接多个对象

Object.assign(对象1，对象2)  【assign】

> 将对象2拼接到对象1上，拼接过程中属性冲突，保留新拼接来的数据(原始数据被覆盖)

```js
var obj1={
    user:"tony"
}
var obj2={
    age:20
}
Object.assign(obj1,obj2)
```

### 获取对象的属性描述符

`Object.getOwnPropertyDescriptors(obj)//获取所有属性`

`Object.getOwnPropertyDescriptor(obj.'属性名')//获取某一个属性`

### 对象的遍历
* for in 会把继承的属性方法也遍历出来
* Object.keys() 遍历出对象所有的属性，方法名
* Object.values() 遍历出对象所有的属性值，方法值
* Object.entries() 遍历出随想所有的属性名和属性值，方法名和方法值


## Date 日期对象
```js
var date=new Date();
```

### 获取时间
1. getFullYear()  获取年份
2. getMonth() 获取月份(从 0 开始)
3. getDay()  获取星期(星期日是0)
4. getDate  获取日
5. getHours() 获取小时
6. getMinutes()  获取分钟
7. getSecinds()  获取秒
8. getTime()  时间戳(1970年1月1日早8点至今的毫秒数)

1. setFullYear()  设置年份
2. setMonth() 设置月份(从 0 开始)
3. setDate  设置日
4. setHours() 设置小时
5. setMinutes()  设置分钟
6. setSecinds()  设置秒

### 时间的转换

> 字符串时间=>日期对象

```js
new Date("2018-9-11")
```
> 日期对象=>字符串时间

* toLocaleString()  按照本地时间格式，将日期对象转化为字
* toLocaleTimeString()  时分秒
* toLocaleDateString()  年月日


```js
//倒计时
var date=new Date()
date.setHours(21)
date.setMinutes(0)
date.setSeconds(0)
var jl=date.getTime()
var now,xz,cha,h,m,s;
var time=function(){
    now=new Date();
    xz=now.getTime()
    cha=(jl-xz)/1000
    h=Math.round(cha/3600)
    m=Math.round(cha/60%60)
    s=Math.round(cha%60)
}
time();
setInterval(time,1000)
```


## 正则对象RegExp
> 数据验证

### 创建正则
1. var reg=new RegExp('正则规则')
2. var reg=/正则规则/
```js
var reg=new RegExp('abc')  //实例化

var str="abd"

reg.test(str)  //验证这个字符串是否符合规则
```

```js
var reg=/abc/  //直接创建
```

### 使用正则
1. text()  验证字符串是否符合正则的规则

2. exec()  根据正则规则进行字符串查找
 * 返回值是一个数组，数组[0]就是查找的数据 index是找到数据的下标  input是原始数据
 * 未找到返回值是null


### 正则规则写法
#### 原子
[0-9a-zA-Z]
* \d  匹配任意一个数字 [0-9]
* \D　与除了数字以外的任何一个字符匹配 [^0-9]
* \w　与任意一个英文字母,数字或下划线匹配[a-z0-9A-Z_]
* \W　除了字母,数字或下划线外与任何一个字符匹[^a-z0-9A-Z_]  
* \s　与任意一个空白字符匹配

* [0-9a-zA-Z-_!@#$%^&*(){}]  自定义写法

#### 边界符
^ 从字符串开头匹配
$ 结尾
```js
var reg=/^abc$/
```
```js
var reg=/^\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d[0-9xX]$/
var str="1405251996040800100"
console.log(reg.test(str))
```

#### 量词

> 原子的个数

1. {个数}
2. {1,5}  前面一个原子个数可能是1个到5个之间
3. {1,}   前面一个原子个数可能是1个到多个
4. *前面一个原子个数可能是0个到多个
5. +前面一个原子个数可能是1个到多个



```js
var reg=/^[0-9a-zA-Z]{1,}@[0-9a-zA-Z]{2,4}.[a-zA-Z]{2,}$/
    var str="949883887@qq.com"
    console.log(reg.test(str))
```

#### 或 |  
| 将正则分为两部分，只要有一部分符合就为true

```js
var reg=/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/
var str='#f0f0f0'
console.log(reg.test(str))
```

#### 模式修正符
1. g  全局查找
2. i  不分大小写


```js
var reg=/张三/