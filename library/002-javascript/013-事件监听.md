## 事件监听

> 为一个事件添加多个事件处理程序

```js
<!--公有的函数-->
var fun=function(){}

div.addEventListener('click',fun)

<!--ie8及以下-->
div.attachEvent('onclick',fun)


<!--兼容性写法-->
if(div.addEventListener){
    div.addEventListener('click',fun)
}
else{
    div.attachEvent('onclick',fun)
}
```

### 移除事件监听
```js
div.removeEventListener('click',fun)
<!--只能移除通过函数名添加的事件-->
```

## 事件流

### 冒泡事件流

> 子元素事件触发，父元素事件也会被触发

#### 阻断冒泡事件流的传递

```js
ev.stopPropagation()
```

#### 阻止浏览器的默认行为

```js
ev.preventDefault()
```

> 滚轮事件(0nwheel)、上下左右翻页(onkeydown)

> 双击选中文字(onmousedown)

> 超链接、表单的跳转(onclick)

#### 阻止浏览器的默认行为(兼容)

`return flase`

##### 兼容性写法，先判断
if(ev.preventDefault){
    ev.preventDefault();
}
else{
    return flase
}


> 放到事件末尾

### 捕获事件流

> 事件开始阶段，先触发window的事件，再触发body，父元素，子元素，以此类推（先触发最不明确的事件源，最后触发最明确的事件源）

```js
div.addEventListener('click',function(){},boolean)
<!--boolena:是否触发捕获事件流，默认false-->
```

> 浏览器默认的事件流是冒泡事件流

### 事件委派

> 将子元素的事件放到父元素上

1. 子元素数量很多
2. 子元素动态添加，不方便直接获取子元素


#### 事件对象
1. ev.path  冒泡事件流的传递流程
2. target  真正的事件源



1. 子元素放到父元素
2. ev.target 获取真正的事件源
3. 判断ev.target是否是要触发的
    * 判断内容：innerHTML/innerText
    * 判断类名：className/classList
        * ev.target.className=='目标类名'
        * ev.target.classList.contains('目标类名'
    * 判断属性：
        * ev.target.属性=='目标属性'
        * ev.target.getAttribute('属性')=='目标属性'
        * ev.target.hasAttribute('属性')  判断某一属性是否存在
    * 判断标签名：
        * ev.target.nodeName     (标签名大写)
4. 
