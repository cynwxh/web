# 对象的扩展

声明，访问，添加属性的方法，遍历，删除

## 对象的封装

> 生成多个属性方法名重复的对象

### 1.工厂函数
```
function getStudent(user,age,tel,sex){
    var obj{}
    obj.user=user;
    obj.age=age;
    obj.tel=tel;
    obj.sex=sex;
    return obj;
}
getStudent("mayun",50,123,"男")
```
### 2.通过 类 封装对象
> 类:类是对象的的抽象

> js中的类称为构造函数

```
function fun(){
    this.属性名= 属性值;【变量】
    
    this.方法名= _=>{};  【变量】
}
```
var obj=new fun()
> 实例化构造函数，可以得到一个对象

构造函数中的this，指向实例化出的对象

### 3.prototype 原型与构造函数混合

> 共有的方法应该公用，工厂函数和构造函数得到的对象独占内存

每个构造函数都有一个原型，原型上存放对象中共有的属性方法

```
function getStudent(user,age){
    this.user=user;
    this.age=age;
}
getStudent.prototype={  //第一种方法
    fun:_=>{
        alert(1);
    }
}
getStudent.prototype.fun=_=>{alert(1)}  //第二种方法
var obj=new getStudent("zhangsan",20)
obj.fun();
```

> 一般情况下，属性放在构造函数，方法放在原型


### 通过原型继承

> 一个对象有另一个对象的方法

将父构造函数的实例化的结果放到子构造函数的原型上

```
function getNomal(num){
    this.num=num;
    this.login=_=>{
        alert(1)
    }
}
function getVip(num){
    this.liwu=_=>{

    }
}
getVip.prototype=new getNomal
var v1=new getVip
v1.login();
```

### 原型链
访问对象的属性或方法，现在对象自身构造函数寻找->自身构造函数的原型->父构造函数->父构造函数的原型->...->Object->Object的原型

### 通过call(对象冒充),applay继承

```
function fu(){
    this.user="fu"
    this.run=function(){
        alert(this.user)
    }
}
function zi(){
    this.user="zi"
}
var obj1=new fu();
var obj2=new zi();
obj1.run.call(obj2)

// 将run方法的this由obj1改为obj2
```

obj1.run.call(obj2,参数1,参数2,参数3)
obj1.run.applay(obj2,[参数1,参数2,参数3])